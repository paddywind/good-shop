// /backend/src/routes/blogRoutes.js
const express = require('express');
const BlogPost = require('../models/BlogPost');
const { protect } = require('../middleware/authMiddleware'); // Assuming this exists
const { upload, uploadToCloudinary, cloudinary } = require('../middleware/cloudinaryMiddleware'); // Assuming this exists
const asyncHandler = require('express-async-handler');
const router = express.Router();

// â¬‡ï¸ Public Routes

// @route   GET /api/blog
// @desc    Get all blog posts (for card list)
// @access  Public
router.get('/', async (req, res) => {
  try {
    // Get only essential fields for cards and sort by newest first
    const posts = await BlogPost.find({})
      .select('title slug author imageUrl createdAt')
      .sort({ createdAt: -1 });
    res.json(posts);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// @route   GET /api/blog/:slug
// @desc    Get single blog post details by slug
// @access  Public
router.get('/:slug', async (req, res) => {
  try {
    // Find by slug instead of ID
    const post = await BlogPost.findOne({ slug: req.params.slug });
    if (!post) {
      return res.status(404).json({ message: 'Blog post not found' });
    }
    res.json(post);
  } catch (error) {
    // Check if it's a valid ObjectId format error (less likely with slug, but good practice)
    res.status(500).json({ message: error.message });
  }
});

// ðŸ”’ Protected Routes (Require JWT authentication/Admin role)

// @route   POST /api/blog
// @desc    Add a new blog post
// @access  Protected (Requires admin privileges)
router.post(
  '/',
  protect, // Middleware to ensure the user is authenticated
  upload.single('featuredImage'), // Handle image upload
  uploadToCloudinary, // Upload the image to Cloudinary
  async (req, res) => {
    try {
      const { title, content, author } = req.body;
      const imageUrl = req.cloudinaryUrl; // Get the URL from the middleware

      if (!title || !content || !author || !imageUrl) {
        return res.status(400).json({ message: 'Please include all required blog fields and a featured image.' });
      }

      // The slug is automatically generated by the Mongoose 'pre' middleware
      const newPost = new BlogPost({ title, content, author, imageUrl });
      const createdPost = await newPost.save();

      res.status(201).json(createdPost);
    } catch (error) {
      // Handle potential duplicate slug error (if the title is the same)
      if (error.code === 11000) {
        return res.status(400).json({ message: 'A post with that title already exists. Please choose a different title.' });
      }
      res.status(500).json({ message: error.message });
    }
  }
);

//  PUT (update by slug) 
router.put(
  '/:slug',
  protect, // Ensure user is authenticated
  upload.single('featuredImage'), // Optional image re-upload
  uploadToCloudinary, // Handles the image upload and sets req.cloudinaryUrl if a file is present
  asyncHandler(async (req, res) => {
    const { title, content, author } = req.body;
    const imageUrl = req.cloudinaryUrl; // New image URL if uploaded

    const post = await BlogPost.findOne({ slug: req.params.slug });

    if (post) {
      // 1. Update fields if provided
      post.title = title || post.title;
      post.content = content || post.content;
      post.author = author || post.author;

      // 2. Update image URL if a new image was uploaded
      if (imageUrl) {
        post.imageUrl = imageUrl;
      }

      // Important: Mongoose's 'pre' middleware for slug generation runs 
      // when 'title' is modified, ensuring the slug is updated if the title changes.
      const updatedPost = await post.save();

      res.json(updatedPost);
    } else {
      res.status(404);
      throw new Error('Blog post not found');
    }
  })
);


// Helper function to extract the Public ID from the Cloudinary URL
const extractPublicId = (imageUrl) => {
  // Regex pattern to extract the part after the folder name and before the version number (or extension)
  const parts = imageUrl.split('/');

  // We expect the path to be like: .../folder_name/public_id.ext
  // Find the index of the folder name ('blog_posts') or the last part of the path before the file
  const folderIndex = parts.indexOf('blog_posts');

  if (folderIndex > -1 && parts.length > folderIndex + 1) {
    const fileName = parts.slice(folderIndex + 1).join('/'); // Get everything after 'blog_posts'
    return fileName.split('.')[0]; // Remove the extension if present (though Cloudinary handles paths better)
  }

  // Simple extraction: assumes path is /folder/public_id.ext
  const idWithExtension = parts.pop();
  const idWithoutExtension = idWithExtension.split('.')[0];

  // We need the folder name as well, which is 'blog_posts'
  return parts.pop() + '/' + idWithoutExtension;
};


// @route   DELETE /api/blog/:slug
// @desc    Delete a blog post by slug
// @access  Protected (Requires admin privileges)
router.delete(
  '/:slug',
  protect,
  asyncHandler(async (req, res) => {
    const post = await BlogPost.findOne({ slug: req.params.slug });

    if (post) {
      // --- 1. Delete the image from Cloudinary ---
      try {
        const publicId = extractPublicId(post.imageUrl);

        // Use the Cloudinary SDK's destroy method
        await cloudinary.uploader.destroy(publicId, (error, result) => {
          if (error) {
            console.error("Cloudinary Deletion Error:", error);
            // We proceed with DB deletion even if image delete fails, 
            // but log the error for cleanup later.
          } else {
            console.log(`Successfully deleted image: ${result.result}`);
          }
        });
      } catch (e) {
        console.error("Error extracting public ID or communicating with Cloudinary:", e);
      }
      // --- ---------------------------------- ---

      // 2. Delete the database record
      await post.deleteOne();

      res.json({ message: 'Blog post and associated image removed successfully' });

    } else {
      res.status(404);
      throw new Error('Blog post not found');
    }
  })
);
module.exports = router;